/*
 *********************************************************************************************************
 *                                             CODE
 *
 *********************************************************************************************************
 */

#ifndef _DUEROS_DMA_PB_H_
#define _DUEROS_DMA_PB_H_

#include<string.h>
#include <stdint.h>
#include "dma_protobuf.h"
/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: dma.proto */


typedef struct _ControlEnvelope ControlEnvelope;
typedef struct _Response Response;
typedef struct _Dialog Dialog;
typedef struct _SpeechInitiator SpeechInitiator;
typedef struct _SpeechInitiator__WakeWord SpeechInitiator__WakeWord;
typedef struct _SpeechSettings SpeechSettings;
typedef struct _StartSpeech StartSpeech;
typedef struct _ProvideSpeech ProvideSpeech;
typedef struct _SpeechProvider SpeechProvider;
typedef struct _StopSpeech StopSpeech;
typedef struct _EndPointSpeech EndPointSpeech;
typedef struct _NotifySpeechState NotifySpeechState;
typedef struct _DeviceInformation DeviceInformation;
typedef struct _PairInformation PairInformation;
typedef struct _DeviceConfiguration DeviceConfiguration;
typedef struct _GetDeviceInformation GetDeviceInformation;
typedef struct _GetDeviceConfiguration GetDeviceConfiguration;
typedef struct _NotifyDeviceConfiguration NotifyDeviceConfiguration;
typedef struct _State State;
typedef struct _GetState GetState;
typedef struct _SetState SetState;
typedef struct _SynchronizeState SynchronizeState;
typedef struct _ForwardATCommand ForwardATCommand;
typedef struct _ForwardTestCommand ForwardTestCommand;


/* --- enums --- */

typedef enum _SpeechInitiator__Type {
    SPEECH_INITIATOR__TYPE__NONE = 0,
    SPEECH_INITIATOR__TYPE__PRESS_AND_HOLD = 1,
    SPEECH_INITIATOR__TYPE__TAP = 3,
    SPEECH_INITIATOR__TYPE__WAKEWORD = 4
                                       PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SPEECH_INITIATOR__TYPE)
} SpeechInitiator__Type;
/*
 * //////////////////////////////////////////////////////////////////////////////
 * 传输层类型。当前还不支持iAP。
 */
typedef enum _Transport {
    TRANSPORT__BLUETOOTH_LOW_ENERGY = 0,
    TRANSPORT__BLUETOOTH_RFCOMM = 1,
    TRANSPORT__BLUETOOTH_IAP = 2
                               PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSPORT)
} Transport;
/*
 * 错误代码类型。
 */
typedef enum _ErrorCode {
    ERROR_CODE__SUCCESS = 0,
    ERROR_CODE__UNKNOWN = 1,
    ERROR_CODE__INTERNAL = 2,
    ERROR_CODE__UNSUPPORTED = 3,
    ERROR_CODE__USER_CANCELLED = 4,
    ERROR_CODE__NOT_FOUND = 5,
    ERROR_CODE__INVALID = 6,
    ERROR_CODE__BUSY = 7,
    /*
     *    *Pair的错误返回：已经被配对了
     *       */
    ERROR_CODE__NOT_IN_PAIR_MODE = 8,
    /*
     *    *签名验证失败
     *       */
    ERROR_CODE__SIGN_VERIFY_FAIL = 9
                                   PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(ERROR_CODE)
} ErrorCode;
/*
 * 控制指令类型。
 */
typedef enum _Command {
    /*
     *Speech Recognition
     */
    COMMAND__PROVIDE_SPEECH = 0,
    COMMAND__PROVIDE_SPEECH_ACK = 1,
    COMMAND__START_SPEECH = 2,
    COMMAND__START_SPEECH_ACK = 3,
    COMMAND__STOP_SPEECH = 4,
    COMMAND__STOP_SPEECH_ACK = 5,
    COMMAND__END_POINT_SPEECH = 6,
    COMMAND__END_POINT_SPEECH_ACK = 7,
    COMMAND__NOTIFY_SPEECH_STATE = 8,
    COMMAND__NOTIFY_SPEECH_STATE_ACK = 9,
    /*
     *Device
     */
    COMMAND__GET_DEVICE_INFORMATION = 20,
    COMMAND__GET_DEVICE_INFORMATION_ACK = 21,
    COMMAND__GET_DEVICE_CONFIGURATION = 22,
    COMMAND__GET_DEVICE_CONFIGURATION_ACK = 23,
    COMMAND__NOTIFY_DEVICE_CONFIGURATION = 24,
    COMMAND__NOTIFY_DEVICE_CONFIGURATION_ACK = 25,
    COMMAND__PAIR = 26,
    COMMAND__PAIR_ACK = 27,
    /*
     *State
     */
    COMMAND__GET_STATE = 30,
    COMMAND__GET_STATE_ACK = 31,
    COMMAND__SET_STATE = 32,
    COMMAND__SET_STATE_ACK = 33,
    COMMAND__SYNCHRONIZE_STATE = 34,
    COMMAND__SYNCHRONIZE_STATE_ACK = 35,
    /*
     *Cellular calling
     */
    COMMAND__FORWARD_AT_COMMAND = 40,
    COMMAND__FORWARD_AT_COMMAND_ACK = 41,
    /*
     *Test command
     */
    COMMAND__FORWARD_TEST_COMMAND = 42,
    COMMAND__FORWARD_TEST_COMMAND_ACK = 43
                                        PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COMMAND)
} Command;
typedef enum _AudioSource {
    AUDIO_SOURCE__STREAM = 0
                           PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_SOURCE)
} AudioSource;
typedef enum _AudioProfile {
    AUDIO_PROFILE__CLOSE_TALK = 0,
    AUDIO_PROFILE__NEAR_FIELD = 1,
    AUDIO_PROFILE__FAR_FIELD = 2
                               PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_PROFILE)
} AudioProfile;
typedef enum _AudioFormat {
    AUDIO_FORMAT__PCM_L16_16KHZ_MONO = 0,
    AUDIO_FORMAT__OPUS_16KHZ_32KBPS_CBR_0_20MS = 1,
    AUDIO_FORMAT__OPUS_16KHZ_16KBPS_CBR_0_20MS = 2,
    AUDIO_FORMAT__MSBC = 3,
    AUDIO_FORMAT__SPEEX_16KHZ_16KBPS = 4,
    AUDIO_FORMAT__SBC_16KHZ_MONO_16KBPS_28BITPOOL_16NUMBLOCKS_8SUBBANDS_SNR = 5
            PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_FORMAT)
} AudioFormat;
typedef enum _SpeechState {
    SPEECH_STATE__IDLE = 0,
    SPEECH_STATE__LISTENING = 1,
    SPEECH_STATE__PROCESSING = 2,
    SPEECH_STATE__SPEAKING = 3
                             PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SPEECH_STATE)
} SpeechState;
typedef enum _InitiatorType {
    /*
     *可选的值："PRESS_AND_HOLD", "TAP", "PHONE_WAKEUP"
     */
    INITIATOR_TYPE__PRESS_AND_HOLD = 0,
    INITIATOR_TYPE__TAP = 1,
    INITIATOR_TYPE__PHONE_WAKEUP = 2,
    INITIATOR_TYPE__WAIT_FOLLOW_WAKEUP = 3
                                         PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(INITIATOR_TYPE)
} InitiatorType;
typedef enum _SignMethod {
    SIGN_METHOD__SHA256 = 0,
    SIGN_METHOD__SHA1 = 1,
    /*
     *不建议使用
     */
    SIGN_METHOD__MD5SUM = 2
                          PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SIGN_METHOD)
} SignMethod;

/* --- messages --- */

typedef enum {
    CONTROL_ENVELOPE__PAYLOAD__NOT_SET = 0,
    CONTROL_ENVELOPE__PAYLOAD_RESPONSE = 9,
    CONTROL_ENVELOPE__PAYLOAD_PROVIDE_SPEECH = 21,
    CONTROL_ENVELOPE__PAYLOAD_START_SPEECH = 22,
    CONTROL_ENVELOPE__PAYLOAD_STOP_SPEECH = 23,
    CONTROL_ENVELOPE__PAYLOAD_END_POINT_SPEECH = 24,
    CONTROL_ENVELOPE__PAYLOAD_NOTIFY_SPEECH_STATE = 25,
    CONTROL_ENVELOPE__PAYLOAD_GET_DEVICE_INFORMATION = 26,
    CONTROL_ENVELOPE__PAYLOAD_GET_DEVICE_CONFIGURATION = 27,
    CONTROL_ENVELOPE__PAYLOAD_NOTIFY_DEVICE_CONFIGURATION = 28,
    CONTROL_ENVELOPE__PAYLOAD_GET_STATE = 29,
    CONTROL_ENVELOPE__PAYLOAD_SET_STATE = 30,
    CONTROL_ENVELOPE__PAYLOAD_SYNCHRONIZE_STATE = 31,
    CONTROL_ENVELOPE__PAYLOAD_FORWARD_ATCOMMAND = 32,
    CONTROL_ENVELOPE__PAYLOAD_FORWARD_TEST_COMMAND = 33
            PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CONTROL_ENVELOPE__PAYLOAD)
} ControlEnvelope__PayloadCase;

/*
 * //////////////////////////////////////////////////////////////////////////////
 * 控制指令封装
 * 每一个发送到控制流的信息都需要被包在ControlEnvelope里面。详细定义如下。
 */
struct  _ControlEnvelope {
    ProtobufCMessage base;
    Command command;
    /*
     *主动发起的command，带上这个参数，Ack的command会照原样带回来，建议长度不超过6个字节
     */
    char *request_id;
    /*
     *sign2与rand2皆为可选字段，用于手机发起的指令的签名，在外设对此字段做相应的鉴权操作，具体清空README.md中关于鉴权的描述
     *目前仅有PROVIDE_SPEECH和GET_STATE(ENTER_OTA_MODE)需要带sign2字段
     *sign2 = sha256(rand2 + rand + key + product\_id + serial\_number)
     *签名算法需要使用PairInformation中的SignMethod
     *起名sign2和rand2是为了区分PairInformation中的sign和rand
     */
    char *sign2;
    /*
     *可选
     */
    char *rand2;
    ControlEnvelope__PayloadCase payload_case;
    union {
        Response *response;
        /*
         *command messages
         */
        ProvideSpeech *providespeech;
        StartSpeech *startspeech;
        StopSpeech *stopspeech;
        EndPointSpeech *endpointspeech;
        NotifySpeechState *notifyspeechstate;
        GetDeviceInformation *getdeviceinformation;
        GetDeviceConfiguration *getdeviceconfiguration;
        NotifyDeviceConfiguration *notifydeviceconfiguration;
        GetState *getstate;
        SetState *setstate;
        SynchronizeState *synchronizestate;
        ForwardATCommand *forwardatcommand;
        ForwardTestCommand *forwardtestcommand;
    };
};
#define CONTROL_ENVELOPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&control_envelope__descriptor) \
    , COMMAND__PROVIDE_SPEECH, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, CONTROL_ENVELOPE__PAYLOAD__NOT_SET, {0} }


typedef enum {
    RESPONSE__PAYLOAD__NOT_SET = 0,
    RESPONSE__PAYLOAD_SPEECH_PROVIDER = 11,
    RESPONSE__PAYLOAD_DEVICE_INFORMATION = 12,
    RESPONSE__PAYLOAD_DEVICE_CONFIGURATION = 13,
    RESPONSE__PAYLOAD_STATE = 14,
    RESPONSE__PAYLOAD_PAIR_INFORMATION = 15
                                         PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(RESPONSE__PAYLOAD)
} Response__PayloadCase;

/*
 * 每一个发送到控制流的控制指令都需要有一个回复（ACK）。
 */
struct  _Response {
    ProtobufCMessage base;
    ErrorCode error_code;
    Response__PayloadCase payload_case;
    union {
        SpeechProvider *speechprovider;
        DeviceInformation *deviceinformation;
        DeviceConfiguration *deviceconfiguration;
        State *state;
        PairInformation *pairinformation;
    };
};
#define RESPONSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&response__descriptor) \
    , ERROR_CODE__SUCCESS, RESPONSE__PAYLOAD__NOT_SET, {0} }


/*
 * //////////////////////////////////////////////////////////////////////////////
 * 能力：语音识别
 */
struct  _Dialog {
    ProtobufCMessage base;
    uint32_t id;
};
#define DIALOG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dialog__descriptor) \
    , 0 }


struct  _SpeechInitiator__WakeWord {
    ProtobufCMessage base;
    uint32_t start_index_in_samples;
    uint32_t end_index_in_samples;
};
#define SPEECH_INITIATOR__WAKE_WORD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_initiator__wake_word__descriptor) \
    , 0, 0 }


struct  _SpeechInitiator {
    ProtobufCMessage base;
    SpeechInitiator__Type type;
    SpeechInitiator__WakeWord *wake_word;
    /*
     *控制手机端是否播放唤醒提示音
     */
    protobuf_c_boolean play_prompt_tone;
};
#define SPEECH_INITIATOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_initiator__descriptor) \
    , SPEECH_INITIATOR__TYPE__NONE, NULL,0 }


struct  _SpeechSettings {
    ProtobufCMessage base;
    AudioProfile audio_profile;
    AudioFormat audio_format;
    AudioSource audio_source;
};
#define SPEECH_SETTINGS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_settings__descriptor) \
    , AUDIO_PROFILE__CLOSE_TALK,  AUDIO_FORMAT__OPUS_16KHZ_16KBPS_CBR_0_20MS, AUDIO_SOURCE__STREAM }


struct  _StartSpeech {
    ProtobufCMessage base;
    SpeechSettings *settings;
    SpeechInitiator *initiator;
    Dialog *dialog;
};
#define START_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&start_speech__descriptor) \
    , NULL, NULL, NULL }


struct  _ProvideSpeech {
    ProtobufCMessage base;
    Dialog *dialog;
};
#define PROVIDE_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&provide_speech__descriptor) \
    , NULL }


struct  _SpeechProvider {
    ProtobufCMessage base;
    SpeechSettings *settings;
    Dialog *dialog;
};
#define SPEECH_PROVIDER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_provider__descriptor) \
    , NULL, NULL }


struct  _StopSpeech {
    ProtobufCMessage base;
    ErrorCode error_code;
    Dialog *dialog;
};
#define STOP_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&stop_speech__descriptor) \
    , ERROR_CODE__SUCCESS, NULL }


struct  _EndPointSpeech {
    ProtobufCMessage base;
    Dialog *dialog;
};
#define END_POINT_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&end_point_speech__descriptor) \
    , NULL }


struct  _NotifySpeechState {
    ProtobufCMessage base;
    SpeechState state;
};
#define NOTIFY_SPEECH_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&notify_speech_state__descriptor) \
    , SPEECH_STATE__IDLE }


/*
 * //////////////////////////////////////////////////////////////////////////////
 * 能力：设备信息
 */
struct  _DeviceInformation {
    ProtobufCMessage base;
    char *serial_number;
    char *name;
    size_t n_supported_transports;
    Transport *supported_transports;
    /*
     *default "3P"(兼容AMA),
     */
    char *device_type;
    size_t n_supported_audio_formats;
    AudioFormat *supported_audio_formats;
    /*
     *厂商
     */
    char *manufacturer;
    /*
     *型号
     */
    char *model;
    char *firmware_version;
    char *software_version;
    /*
     *设备支持的语音交互方式
     */
    InitiatorType initiator_type;
    /*
     *产品id需要从度秘平台获得, 为空的时候，判定设备为UNKONWN或者OTHER。 长度不超过32字节
     */
    char *product_id;
    /*
     *类似06:36:3b:cd:c1:b0
     */
    char *classic_bluetooth_mac;
    /*
     *如果这个字段为false，手机端会每1-2秒发一个GET_STATE的请求，作为设备的心跳包。设为true的时候，手机不发送心跳请求
     */
    protobuf_c_boolean disable_heart_beat;
    /*
     *如果这个字段为true，手机端生成sign2的时候会做第二次hash, new_sign2 = sign_method ( sign2 + requestId + int2string(command))，具体逻辑请看README.md中的“高级安全”部分
     */
    protobuf_c_boolean enable_advanced_security;
    /*
     *可选，默认为false；标识设备是否使用FM发射的方式播放音频。如果这个字段为true。app连接外设成功之后会触发fm发射频率设置的逻辑。
     */
    protobuf_c_boolean support_fm;
    /*
     *可选，标识外设上负责ota软件的版本。ota的软件和实现功能的软件（software_version）是独立的，所以版本号也独立
     */
    char *ota_version;
};
#define DEVICE_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&device_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL, (char *)protobuf_c_empty_string, 0,NULL, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, INITIATOR_TYPE__TAP, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string,0,0, 0, (char *)protobuf_c_empty_string}

struct  _PairInformation {
    ProtobufCMessage base;
    /*
     *长度8位的随机字符串。注意：需要每次返回都不一样，一旦返回后，需要把这个值保存下来，供ProvideSpeech的签名验证使用。具体逻辑请看README.md中的鉴权部分
     */
    char *rand;
    /*
     *sign = sha256(rand + key + product_id + serial_number),  key需要从度秘平台获得。具体逻辑请看README.md中的鉴权部分
     */
    char *sign;
    /*
     *签名算法
     */
    SignMethod signmethod;
};
#define PAIR_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&pair_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, SIGN_METHOD__SHA256 }

struct  _DeviceConfiguration {
    ProtobufCMessage base;
    /*
     *现在都是false，不需要
     */
    protobuf_c_boolean needs_assistant_override;
    protobuf_c_boolean needs_setup;
};
#define DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&device_configuration__descriptor) \
    , 0, 0 }


struct  _GetDeviceInformation {
    ProtobufCMessage base;
};
#define GET_DEVICE_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_device_information__descriptor) \
     }


struct  _GetDeviceConfiguration {
    ProtobufCMessage base;
};
#define GET_DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_device_configuration__descriptor) \
     }


struct  _NotifyDeviceConfiguration {
    ProtobufCMessage base;
};
#define NOTIFY_DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&notify_device_configuration__descriptor) \
     }


////////////////////////////////////////////////////////////////////////////////
// 能力：状态查询

typedef enum {
    // protol3 枚举类型定义必须是0开头，
    UNKNOWN_BOOLEAN_TYPE = 0,
    DMA_ALIVE = 0x01,
    DMA_SIGN_VERIFY = 0x02,
    // 外设的aux端口（3.5mm耳机端口）是否连接了  外设 get, set, sync
    AUX_CONNECTED = 0x100,
    // 外设是否支持A2DP  外设 get, set, sync
    A2DP_ENABLED = 0x130,
    // 外设是否支持HFP  外设 get, set, sync
    HFP_ENABLED = 0x131,
    // 外设是否连接了A2DP  外设 get, sync
    A2DP_CONNECTED = 0x132,
    // 外设是否连接了HFP  外设 get, sync
    HFP_CONNECTED = 0x133,
    // 是否能在标准蓝牙下被发现  外设 get, sync
    BT_CLASSIC_DISCOVERABLE = 0x134,
    // 是否设备校准被请求  外设 get, sync
    DEVICE_CALIBRATION_REQUIRED = 0x200,
    // （手机）是否启用了“勿扰模式”  手机 get, sync
    DEVICE_DND_ENABLED = 0x202,
    // (大黄蜂)外设红外传感器 外设 get, sync
    DHF_infrared_Detected = 0xF001,
    // (大黄蜂)OTA模式 外设 set
    DHF_OTA_MODE = 0xF002,
} FeatureBooleanType;

typedef enum {
    // protol3 枚举类型定义必须是0开头，
    UNKNOWN_INTEGER_TYPE = 0,
    // 显示模式 外设 get, set
    // Integer Type:
    //    * 1 - auto
    //    * 2 - disabled
    //    * 3 - day mode 白天模式
    //    * 4 - night mode 夜间模式
    DEVICE_THEME = 0x201,
    // 手机联网状态 手机 get, sync
    // Integer Type:
    //    * 0 - 正常
    //    * 1 - 太慢（或者连不上）
    //    * 2 - DuerOS服务不可用
    CELLULAR_CONNECTIVITY_STATUS = 0x203,
    // 消息推送通知 手机 get, sync
    // Integer Type:
    //    * 0 - 没有消息
    //    * 1 - 有未读消息
    MESSAGE_NOTIFICATION = 0x300,

    // 电话通知 手机 get, sync
    // Integer Type:
    //    * 0 - 无
    //    * 1 - 有未接来电
    //    * 2 - 正在来电（未接听）
    //    * 3 - 正在呼叫中
    //    * 4 - 正在来电（接听中）
    CALL_NOTIFICATION = 0x301,

    // 其他通知 手机 get, sync
    // Integer Type (bit map, 大端表示) :
    //    * 0 - 无
    //    * 1 - 闹钟被触发
    //    * 2 - 计时器被触发
    //    * 3 - 事件提醒被触发
    //    * 4 - 系统通知被触发
    REMOTE_NOTIFICATION = 0x302,
    //(大黄蜂)写入FM发射频率 外设 get, set
    //Integer Type:
    //          FM频率(Mhz)乘以10
    DHF_FM_Frequency = 0xF003,
    //DCS所处的场景模式 外设 set
    //Integer Type:
    //    * 0 - 正常
    //    * 1 - 儿童模式
    //    * 2 - 极客模式
    DCS_scene_Mode = 0xF007,
} FeatureIntegerType;

typedef enum {
    STATE__VALUE__NOT_SET = 0,
    STATE__VALUE_BOOLEAN = 2,
    STATE__VALUE_INTEGER = 3
                           PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STATE__VALUE)
} State__ValueCase;

struct  _State {
    ProtobufCMessage base;
    uint32_t feature;
    State__ValueCase value_case;
    union {
        protobuf_c_boolean boolean;
        uint32_t integer;
    };
};
#define STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&state__descriptor) \
    , 0, STATE__VALUE__NOT_SET, {0} }


struct  _GetState {
    ProtobufCMessage base;
    uint32_t feature;
};
#define GET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_state__descriptor) \
    , 0 }


struct  _SetState {
    ProtobufCMessage base;
    State *state;
};
#define SET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&set_state__descriptor) \
    , NULL }


struct  _SynchronizeState {
    ProtobufCMessage base;
    State *state;
};
#define SYNCHRONIZE_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&synchronize_state__descriptor) \
    , NULL }


struct  _ForwardATCommand {
    ProtobufCMessage base;
    char *command;
};
#define FORWARD_ATCOMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&forward_atcommand__descriptor) \
    , (char *)protobuf_c_empty_string }

struct  _ForwardTestCommand {
    ProtobufCMessage base;
    char *command;
};
#define FORWARD_TEST_COMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&forward_test_command__descriptor) \
    , (char *)protobuf_c_empty_string }

/* ControlEnvelope methods */
void   control_envelope__init
(ControlEnvelope         *message);
size_t control_envelope__get_packed_size
(const ControlEnvelope   *message);
size_t control_envelope__pack
(const ControlEnvelope   *message,
 uint8_t             *out);
size_t control_envelope__pack_to_buffer
(const ControlEnvelope   *message,
 ProtobufCBuffer     *buffer);
ControlEnvelope *
control_envelope__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   control_envelope__free_unpacked
(ControlEnvelope *message,
 ProtobufCAllocator *allocator);
/* Response methods */
void   response__init
(Response         *message);
size_t response__get_packed_size
(const Response   *message);
size_t response__pack
(const Response   *message,
 uint8_t             *out);
size_t response__pack_to_buffer
(const Response   *message,
 ProtobufCBuffer     *buffer);
Response *
response__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   response__free_unpacked
(Response *message,
 ProtobufCAllocator *allocator);
/* Dialog methods */
void   dialog__init
(Dialog         *message);
size_t dialog__get_packed_size
(const Dialog   *message);
size_t dialog__pack
(const Dialog   *message,
 uint8_t             *out);
size_t dialog__pack_to_buffer
(const Dialog   *message,
 ProtobufCBuffer     *buffer);
Dialog *
dialog__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   dialog__free_unpacked
(Dialog *message,
 ProtobufCAllocator *allocator);
/* SpeechInitiator__WakeWord methods */
void   speech_initiator__wake_word__init
(SpeechInitiator__WakeWord         *message);
/* SpeechInitiator methods */
void   speech_initiator__init
(SpeechInitiator         *message);
size_t speech_initiator__get_packed_size
(const SpeechInitiator   *message);
size_t speech_initiator__pack
(const SpeechInitiator   *message,
 uint8_t             *out);
size_t speech_initiator__pack_to_buffer
(const SpeechInitiator   *message,
 ProtobufCBuffer     *buffer);
SpeechInitiator *
speech_initiator__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   speech_initiator__free_unpacked
(SpeechInitiator *message,
 ProtobufCAllocator *allocator);
/* SpeechSettings methods */
void   speech_settings__init
(SpeechSettings         *message);
size_t speech_settings__get_packed_size
(const SpeechSettings   *message);
size_t speech_settings__pack
(const SpeechSettings   *message,
 uint8_t             *out);
size_t speech_settings__pack_to_buffer
(const SpeechSettings   *message,
 ProtobufCBuffer     *buffer);
SpeechSettings *
speech_settings__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   speech_settings__free_unpacked
(SpeechSettings *message,
 ProtobufCAllocator *allocator);
/* StartSpeech methods */
void   start_speech__init
(StartSpeech         *message);
size_t start_speech__get_packed_size
(const StartSpeech   *message);
size_t start_speech__pack
(const StartSpeech   *message,
 uint8_t             *out);
size_t start_speech__pack_to_buffer
(const StartSpeech   *message,
 ProtobufCBuffer     *buffer);
StartSpeech *
start_speech__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   start_speech__free_unpacked
(StartSpeech *message,
 ProtobufCAllocator *allocator);
/* ProvideSpeech methods */
void   provide_speech__init
(ProvideSpeech         *message);
size_t provide_speech__get_packed_size
(const ProvideSpeech   *message);
size_t provide_speech__pack
(const ProvideSpeech   *message,
 uint8_t             *out);
size_t provide_speech__pack_to_buffer
(const ProvideSpeech   *message,
 ProtobufCBuffer     *buffer);
ProvideSpeech *
provide_speech__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   provide_speech__free_unpacked
(ProvideSpeech *message,
 ProtobufCAllocator *allocator);
/* SpeechProvider methods */
void   speech_provider__init
(SpeechProvider         *message);
size_t speech_provider__get_packed_size
(const SpeechProvider   *message);
size_t speech_provider__pack
(const SpeechProvider   *message,
 uint8_t             *out);
size_t speech_provider__pack_to_buffer
(const SpeechProvider   *message,
 ProtobufCBuffer     *buffer);
SpeechProvider *
speech_provider__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   speech_provider__free_unpacked
(SpeechProvider *message,
 ProtobufCAllocator *allocator);
/* StopSpeech methods */
void   stop_speech__init
(StopSpeech         *message);
size_t stop_speech__get_packed_size
(const StopSpeech   *message);
size_t stop_speech__pack
(const StopSpeech   *message,
 uint8_t             *out);
size_t stop_speech__pack_to_buffer
(const StopSpeech   *message,
 ProtobufCBuffer     *buffer);
StopSpeech *
stop_speech__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   stop_speech__free_unpacked
(StopSpeech *message,
 ProtobufCAllocator *allocator);
/* EndPointSpeech methods */
void   end_point_speech__init
(EndPointSpeech         *message);
size_t end_point_speech__get_packed_size
(const EndPointSpeech   *message);
size_t end_point_speech__pack
(const EndPointSpeech   *message,
 uint8_t             *out);
size_t end_point_speech__pack_to_buffer
(const EndPointSpeech   *message,
 ProtobufCBuffer     *buffer);
EndPointSpeech *
end_point_speech__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   end_point_speech__free_unpacked
(EndPointSpeech *message,
 ProtobufCAllocator *allocator);
/* NotifySpeechState methods */
void   notify_speech_state__init
(NotifySpeechState         *message);
size_t notify_speech_state__get_packed_size
(const NotifySpeechState   *message);
size_t notify_speech_state__pack
(const NotifySpeechState   *message,
 uint8_t             *out);
size_t notify_speech_state__pack_to_buffer
(const NotifySpeechState   *message,
 ProtobufCBuffer     *buffer);
NotifySpeechState *
notify_speech_state__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   notify_speech_state__free_unpacked
(NotifySpeechState *message,
 ProtobufCAllocator *allocator);
/* DeviceInformation methods */
void   device_information__init
(DeviceInformation         *message);
size_t device_information__get_packed_size
(const DeviceInformation   *message);
size_t device_information__pack
(const DeviceInformation   *message,
 uint8_t             *out);
size_t device_information__pack_to_buffer
(const DeviceInformation   *message,
 ProtobufCBuffer     *buffer);
DeviceInformation *
device_information__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   device_information__free_unpacked
(DeviceInformation *message,
 ProtobufCAllocator *allocator);


/* PairInformation methods */
void   pair_information__init
(PairInformation         *message);
size_t pair_information__get_packed_size
(const PairInformation   *message);
size_t pair_information__pack
(const PairInformation   *message,
 uint8_t             *out);
size_t pair_information__pack_to_buffer
(const PairInformation   *message,
 ProtobufCBuffer     *buffer);
PairInformation *
pair_information__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   pair_information__free_unpacked
(PairInformation *message,
 ProtobufCAllocator *allocator);

/* DeviceConfigration methods */
void   device_configuration__init
(DeviceConfiguration         *message);
size_t device_configuration__get_packed_size
(const DeviceConfiguration   *message);
size_t device_configuration__pack
(const DeviceConfiguration   *message,
 uint8_t             *out);
size_t device_configuration__pack_to_buffer
(const DeviceConfiguration   *message,
 ProtobufCBuffer     *buffer);
DeviceConfiguration *
device_configuration__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   device_configuration__free_unpacked
(DeviceConfiguration *message,
 ProtobufCAllocator *allocator);
/* GetDeviceInformation methods */
void   get_device_information__init
(GetDeviceInformation         *message);
size_t get_device_information__get_packed_size
(const GetDeviceInformation   *message);
size_t get_device_information__pack
(const GetDeviceInformation   *message,
 uint8_t             *out);
size_t get_device_information__pack_to_buffer
(const GetDeviceInformation   *message,
 ProtobufCBuffer     *buffer);
GetDeviceInformation *
get_device_information__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   get_device_information__free_unpacked
(GetDeviceInformation *message,
 ProtobufCAllocator *allocator);
/* GetDeviceConfiguration methods */
void   get_device_configuration__init
(GetDeviceConfiguration         *message);
size_t get_device_configuration__get_packed_size
(const GetDeviceConfiguration   *message);
size_t get_device_configuration__pack
(const GetDeviceConfiguration   *message,
 uint8_t             *out);
size_t get_device_configuration__pack_to_buffer
(const GetDeviceConfiguration   *message,
 ProtobufCBuffer     *buffer);
GetDeviceConfiguration *
get_device_configuration__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   get_device_configuration__free_unpacked
(GetDeviceConfiguration *message,
 ProtobufCAllocator *allocator);
/* NotifyDeviceConfigration methods */
void   notify_device_configuration__init
(NotifyDeviceConfiguration         *message);
size_t notify_device_configuration__get_packed_size
(const NotifyDeviceConfiguration   *message);
size_t notify_device_configuration__pack
(const NotifyDeviceConfiguration   *message,
 uint8_t             *out);
size_t notify_device_configuration__pack_to_buffer
(const NotifyDeviceConfiguration   *message,
 ProtobufCBuffer     *buffer);
NotifyDeviceConfiguration *
notify_device_configuration__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   notify_device_configuration__free_unpacked
(NotifyDeviceConfiguration *message,
 ProtobufCAllocator *allocator);
/* State methods */
void   state__init
(State         *message);
size_t state__get_packed_size
(const State   *message);
size_t state__pack
(const State   *message,
 uint8_t             *out);
size_t state__pack_to_buffer
(const State   *message,
 ProtobufCBuffer     *buffer);
State *
state__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   state__free_unpacked
(State *message,
 ProtobufCAllocator *allocator);
/* GetState methods */
void   get_state__init
(GetState         *message);
size_t get_state__get_packed_size
(const GetState   *message);
size_t get_state__pack
(const GetState   *message,
 uint8_t             *out);
size_t get_state__pack_to_buffer
(const GetState   *message,
 ProtobufCBuffer     *buffer);
GetState *
get_state__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   get_state__free_unpacked
(GetState *message,
 ProtobufCAllocator *allocator);
/* SetState methods */
void   set_state__init
(SetState         *message);
size_t set_state__get_packed_size
(const SetState   *message);
size_t set_state__pack
(const SetState   *message,
 uint8_t             *out);
size_t set_state__pack_to_buffer
(const SetState   *message,
 ProtobufCBuffer     *buffer);
SetState *
set_state__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   set_state__free_unpacked
(SetState *message,
 ProtobufCAllocator *allocator);
/* SynchronizeState methods */
void   synchronize_state__init
(SynchronizeState         *message);
size_t synchronize_state__get_packed_size
(const SynchronizeState   *message);
size_t synchronize_state__pack
(const SynchronizeState   *message,
 uint8_t             *out);
size_t synchronize_state__pack_to_buffer
(const SynchronizeState   *message,
 ProtobufCBuffer     *buffer);
SynchronizeState *
synchronize_state__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   synchronize_state__free_unpacked
(SynchronizeState *message,
 ProtobufCAllocator *allocator);
/* ForwardATCommand methods */
void   forward_atcommand__init
(ForwardATCommand         *message);
size_t forward_atcommand__get_packed_size
(const ForwardATCommand   *message);
size_t forward_atcommand__pack
(const ForwardATCommand   *message,
 uint8_t             *out);
size_t forward_atcommand__pack_to_buffer
(const ForwardATCommand   *message,
 ProtobufCBuffer     *buffer);
ForwardATCommand *
forward_atcommand__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   forward_atcommand__free_unpacked
(ForwardATCommand *message,
 ProtobufCAllocator *allocator);

/* ForwardTestCommand methods */
void   forward_test_command__init
(ForwardTestCommand         *message);
size_t forward_test_command__get_packed_size
(const ForwardTestCommand   *message);
size_t forward_test_command__pack
(const ForwardTestCommand   *message,
 uint8_t             *out);
size_t forward_test_command__pack_to_buffer
(const ForwardTestCommand   *message,
 ProtobufCBuffer     *buffer);
ForwardTestCommand *
forward_test_command__unpack
(ProtobufCAllocator  *allocator,
 size_t               len,
 const uint8_t       *data);
void   forward_test_command__free_unpacked
(ForwardTestCommand *message,
 ProtobufCAllocator *allocator);

/* --- per-message closures --- */

typedef void (*ControlEnvelope_Closure)
(const ControlEnvelope *message,
 void *closure_data);
typedef void (*Response_Closure)
(const Response *message,
 void *closure_data);
typedef void (*Dialog_Closure)
(const Dialog *message,
 void *closure_data);
typedef void (*SpeechInitiator__WakeWord_Closure)
(const SpeechInitiator__WakeWord *message,
 void *closure_data);
typedef void (*SpeechInitiator_Closure)
(const SpeechInitiator *message,
 void *closure_data);
typedef void (*SpeechSettings_Closure)
(const SpeechSettings *message,
 void *closure_data);
typedef void (*StartSpeech_Closure)
(const StartSpeech *message,
 void *closure_data);
typedef void (*ProvideSpeech_Closure)
(const ProvideSpeech *message,
 void *closure_data);
typedef void (*SpeechProvider_Closure)
(const SpeechProvider *message,
 void *closure_data);
typedef void (*StopSpeech_Closure)
(const StopSpeech *message,
 void *closure_data);
typedef void (*EndPointSpeech_Closure)
(const EndPointSpeech *message,
 void *closure_data);
typedef void (*NotifySpeechState_Closure)
(const NotifySpeechState *message,
 void *closure_data);
typedef void (*DeviceInformation_Closure)
(const DeviceInformation *message,
 void *closure_data);
typedef void (*PairInformation_Closure)
(const PairInformation *message,
 void *closure_data);
typedef void (*DeviceConfiguration_Closure)
(const DeviceConfiguration *message,
 void *closure_data);
typedef void (*GetDeviceInformation_Closure)
(const GetDeviceInformation *message,
 void *closure_data);
typedef void (*GetDeviceConfiguration_Closure)
(const GetDeviceConfiguration *message,
 void *closure_data);
typedef void (*NotifyDeviceConfiguration_Closure)
(const NotifyDeviceConfiguration *message,
 void *closure_data);
typedef void (*State_Closure)
(const State *message,
 void *closure_data);
typedef void (*GetState_Closure)
(const GetState *message,
 void *closure_data);
typedef void (*SetState_Closure)
(const SetState *message,
 void *closure_data);
typedef void (*SynchronizeState_Closure)
(const SynchronizeState *message,
 void *closure_data);
typedef void (*ForwardATCommand_Closure)
(const ForwardATCommand *message,
 void *closure_data);
typedef void (*ForwardTestCommand_Closure)
(const ForwardTestCommand *message,
 void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    transport__descriptor;
extern const ProtobufCEnumDescriptor    error_code__descriptor;
extern const ProtobufCEnumDescriptor    command__descriptor;
extern const ProtobufCEnumDescriptor    audio_source__descriptor;
extern const ProtobufCEnumDescriptor    audio_profile__descriptor;
extern const ProtobufCEnumDescriptor    audio_format__descriptor;
extern const ProtobufCEnumDescriptor    speech_state__descriptor;
extern const ProtobufCEnumDescriptor    initiator_type__descriptor;
extern const ProtobufCEnumDescriptor    sign_method__descriptor;
extern const ProtobufCMessageDescriptor control_envelope__descriptor;
extern const ProtobufCMessageDescriptor response__descriptor;
extern const ProtobufCMessageDescriptor dialog__descriptor;
extern const ProtobufCMessageDescriptor speech_initiator__descriptor;
extern const ProtobufCMessageDescriptor speech_initiator__wake_word__descriptor;
extern const ProtobufCEnumDescriptor    speech_initiator__type__descriptor;
extern const ProtobufCMessageDescriptor speech_settings__descriptor;
extern const ProtobufCMessageDescriptor start_speech__descriptor;
extern const ProtobufCMessageDescriptor provide_speech__descriptor;
extern const ProtobufCMessageDescriptor speech_provider__descriptor;
extern const ProtobufCMessageDescriptor stop_speech__descriptor;
extern const ProtobufCMessageDescriptor end_point_speech__descriptor;
extern const ProtobufCMessageDescriptor notify_speech_state__descriptor;
extern const ProtobufCMessageDescriptor device_information__descriptor;
extern const ProtobufCMessageDescriptor pair_information__descriptor;
extern const ProtobufCMessageDescriptor device_configuration__descriptor;
extern const ProtobufCMessageDescriptor get_device_information__descriptor;
extern const ProtobufCMessageDescriptor get_device_configuration__descriptor;
extern const ProtobufCMessageDescriptor notify_device_configuration__descriptor;
extern const ProtobufCMessageDescriptor state__descriptor;
extern const ProtobufCMessageDescriptor get_state__descriptor;
extern const ProtobufCMessageDescriptor set_state__descriptor;
extern const ProtobufCMessageDescriptor synchronize_state__descriptor;
extern const ProtobufCMessageDescriptor forward_atcommand__descriptor;
extern const ProtobufCMessageDescriptor forward_test_command__descriptor;



#endif
